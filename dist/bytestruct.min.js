const e=/(le|be)|(?:([fsu])(8|16|32|64))|(\d+)|(\w+):|(\s+)|(.)/g,t={8:1,16:2,32:4,64:8},l={f:"Float",s:"Int",u:"Uint"};export function bytes(t,...l){let n,o,s=0,r=[];const f=(e,t)=>{({0:()=>{if(t[1])n="le"===t[1];else if(t[2]){let e=t[2],l=t[3],s={name:e,size:l,littleEndian:n};null!=o&&(s.label=o,o=void 0),r.push(s)}else t[5]?o=t[5]:"*"===t[7]&&(s=1)},1:()=>{if(t[4]){const e=parseInt(t[4]);r.at(-1).repeat=e,s=0}}})[s]()};for(let n=0;n<t.length;n++){const o=t[n],s=o.matchAll(e);for(const e of s)e[6]||f(void 0,e);n<l.length&&f(l[n])}return r}export function sizeOf(e){let l=0;for(const n of e){let e=t[n.size];n.repeat&&(e*=n.repeat),l+=e}return l}export function readBytesFrom(e,n,o){let s=o,r=[];for(let o=0;o<e.length;o++){const{name:f,size:i,littleEndian:c,repeat:u,label:d}=e[o];let p=l[f],a=t[i];("s"===f||"u"===f&&64===i)&&(p=`Big${p}`),d&&(r.fields??={});const g=n[`get${p}${i}`].bind(n);if(u){d&&(r.fields[d]=[]);for(let e=0;e<u;e++){const t=g(s,c);r.push(t),d&&(r.fields[d][e]=t),s+=a}}else{const e=r[o]=g(s,c);d&&(r.fields[d]=e),s+=a}}return r}export function writeBytesInto(e,n,o,s){let r=s,f=0;for(let s=0;s<e.length;s++){const{name:i,size:c,littleEndian:u,repeat:d}=e[s];let p=l[i],a=t[c];("s"===i||"u"===i&&64===c)&&(p=`Big${p}`);let g=o[`set${p}${c}`].bind(o);if(d)for(let e=0;e<d;e++)g(r,n[f],u),r+=a,f+=1;else g(r,n[f],u),r+=a,f+=1}return r-s}
